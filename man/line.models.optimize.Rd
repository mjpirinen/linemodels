% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/linemodels.R
\name{line.models.optimize}
\alias{line.models.optimize}
\title{Optimize parameters of line models}
\usage{
line.models.optimize(
  X,
  SE,
  par.include = matrix(TRUE, nrow = length(init.slopes), ncol = 3),
  force.same.scales = FALSE,
  init.scales,
  init.slopes,
  init.cors,
  model.priors = rep(1, length(init.slopes)),
  model.names = NULL,
  r.lkhood = 0,
  tol.loglk = 0.001,
  tol.par = 0,
  return.weights = FALSE,
  print.steps = 1
)
}
\arguments{
\item{X}{matrix of effect sizes with two columns (one col per trait)}

\item{SE}{matrix of standard errors with two columns (one col per trait)}

\item{par.include}{matrix of TRUE/FALSE values TRUE indicating which parameters
are optimized. One row per model and 3 columns corresponding
to 'scales', 'slopes' and 'cors', respectively.}

\item{force.same.scales}{logical; If TRUE, then forces all scale parameters equal}

\item{init.scales}{vector of initial standard deviations of larger effect of each model}

\item{init.slopes}{vector of initial slopes of each model}

\item{init.cors}{vector of initial correlation parameters of each model}

\item{model.priors}{vector of initial prior probabilities of models up to a normalization constant}

\item{model.names}{vector of names of each model}

\item{r.lkhood}{correlation between estimators of the two effects}

\item{tol.loglk}{tolerance for convergence in adjacent log-likelihoods}

\item{tol.par}{tolerance for convergence in maximum of absolute values of relative differences
across parameters between adjacent iterations. Can be set negative to determine
the convergence solely by log-likelihood.}

\item{return.weights}{logical; If TRUE returns both optimized mixture weights and
optimized parameters. If FALSE returns only optimized parameters.}

\item{print.steps}{numeric;
If 0, no optimization results are printed on screen.
If 1, prints optimization results at start and end of each optimization call (default).
If >1 prints status after every optimization iteration.}
}
\value{
If 'return.weights' = FALSE, returns matrix with models in rows and columns:
(1) scales, (2) slopes, (3) correlations.
If 'return.weights = TRUE, then returns a list with two components
}
\description{
Consider two effects:  x = effect1 and y = effect2.
The line models are defined by three parameters:
scale = standard deviation of the (larger) effect,
slope = slope of line around which the effects are scattered,
cor = non-negative correlation between effects,
where cor = 1 means the same effect and cor = 0 means independent effects.
}
\details{
A line model has the following properties:

1) effects are scattered around line y = slope*x.
   'slope' can be any real number or Inf (in which case effect x is zero).

2) the larger of the prior variances of effects is scale^2.
   That is, if |slope| <= 1, then Var(x) = scale^2 and
            if |slope| > 1, then Var(y) = scale^2.

3) Distribution around the line is determined as follows.
   Consider a distribution scattered around line y = x with the given correlation.
   Rotate that distribution by an orthogonal rotation defined by angle
   theta = atan(slope) - pi/4
   and use the corresponding distribution, scaled so that the maximum variance
   of the two effects is scale^2.
   NOTE: This is not same as having the given correlation around line y = slope*x,
         because the shape of that distribution depends on the slope but
         definition we use here is independent of slope (up to an orthogonal transformation).

This function optimizes over any set of scales, slopes and cors.
The parameters not included in optimization are fixed to their initial values.
Proportion parameters are always optimized.
}
\examples{
line.models.optimize(
     X = linemodels.ex1[,1:2],
     SE = linemodels.ex1[,3:4],
     par.include = rbind(c(F,F,F), c(F,T,T), c(F,F,F)),
     force.same.scales = FALSE,
     init.scales = c(0.2, 0.2, 0.2),
     init.slopes = c(0, 0.2, 1),
     init.cors = c(0.995, 0.5, 0.995))
}
